변수

변수를 선언할수 있다
변수 선언 방법
자료형 변수명 = 초기값;

기본 자료형 종류
    값을저장
    정수
        -byte, short, int, long
    실수
        - float, double
    문자
        - char
    논리
        - boolean

    변수명 작성 규칙
        - 숫자가 첫 글자로 올 수 업삳
        - 중복 선언이 불가능 하다
        - 대소문자를 구별한다
        - 특수 문자는 _와 $만 가능하다. 공백도 불가능
        - 예약어(키워드)를 사용할 수 없다.

    변수명 작성 관례
        - 카멜 표기법
         - 변수명은 소문자로 작성
         - 여러 영어 단어로 된 경우 두번째 단어부터 첫 글자만 대문자로 작성
        - 변수명은 의미있게 작성
        - 상수는 대문자로 작성, 여러 단어인 경우 _로 구분

    자료형 변환
        - 변수나 값의 자료형을 일시적으로 변환하는 것

        - 자동 형변환
         - 형변환을 직접 하지 않아도 자동으로 변환

         - 작은 크기의 자료형을 큰 크기의 자료형에 저장하거나 연산하는 경우
          - long num = 1;
          - 1이라는 int형을 long형으로 변환하여 저장

        - 정수를 실수로 변환
         - double num = 1;
         - 1이라는 int 정수형을 double 실수형으로 변환하여 저장

        - 강제 형변환(명시적)
         - 반드시 형변환 표시를 해줘야 함
          - (바꾸려는자료형)

         - 큰 크기의 자료형을 작은 크기의 자료형에 저장하거나 연산하는 경우
          - int num = (int)1L;
          - 1L이라는 long형을 int로 변환하여 저장할때, (int)를 반드시 붙여야 함.

         - 실수를 정수로 변환
          - int num = (int)3.14;
          - 3.14라는 double 실수형을 int정수형으로 변환하여 저장할 때, (int)를 반드시 붙여야 함.

         - 필요에 의해 형변환
          - 나누기 할때 정수 / 정수 는 결과가 정수가 되서 
            소수점이 사라지는 현상을 막기 위해 형변환을 함
          - 1 / 2 => 0 이 되기 때문에 1 / (double)2 를 해서 0.5가 나오도록 할 때 사용

---------------------------------------------------------------------------------------
연산자
    - 연산자 종류를 알고, 결과를 예측할 수 있다
    1. 대입 연산자
        - =
        - 오른쪽 값을 왼쪽에 저장
        - 왼쪽에는 변수만 올 수 있다
        - 비교 연산자 ==와 구분

    2. 산술 연산자
        - +, -, *, /, %
        - 정수 산술 연산자 정수 => 정수
            1 / 2 => 0
        - 나누기 할 때 조심
        - % : 나머지 연산자
    
    3. 논리 연산자
        - &&, ||, !
        1. && (AND)
            - ~하고, ~이고
            - 둘 다 참일때 참, 나머지는 거짓

        2. || (OR)
            - ~이거나
            - 둘다 거짓일때 거짓, 나머지는 참

        3. ! (NOT)
            - 반대
            - 참일때 거짓, 거짓일때 참

    4. 비교 연산자
        - <, >, <=, >=, ==, !=
        - 결과가 참 또는 거짓
        - 대입연산자 = 와 비교연산자 == 를 구분해야함

    5. 증감 연산자
        - ++, --
        - 최종적으로 1증가 또는 1감소
        1. 전위형
            - 변수 앞에 배치
            - 증감 하고 동작

        2. 후위형
            - 변수 뒤에 배치
            - 동작후에 증감



    6. 조건 선택 연산자
        - (조건식) ? 참 : 거짓
        - 조건이 참일때 참을 가져오고, 거짓일 때 거짓을 가져옴
        - 조건문으로 대체가능
        - 이 연산자를 이용하면 코드가 간결해지는 경우가 있어서 알아두면 편함

    7. 비트 연산자 [몰라도 크게 지장 없음]
        - 비트를 이용한 연산자
        - &, |, ~, ^
        - >>, <<, >>>

-----------------------------------------------------------------------------------
조건문
    - 조건문을 이용하여 다양한 상황을 처리할 수 있다
    - ~이면 ...한다
        ~ : 조건식
        ...: 실행문

    1. if문
        - 모든 조건문은 if문으로 표현 가능
        - 문법
        if(조건식1){
            실행문1;
        } else if(조건식2){
            실행문2;
        } else{
            실행문3;
        }
        - else if와 else는 없을 수도 있다
        - else if는 여러개 올 수 있다
        - if는 무조건 있어야 함
        - if는 ~하면, else는 else위의 모든 조건식이 거짓이면으로 해석
    
    2. switch문
        - 일부 조건문을 이용할 때 사용
        - 문법
        switch(변수) {
            case 1:
                실행문1;
                break;
            case 2:
                실행문2;
                break;
            default:
                실행문3;
        }
        - break는 switch문을 빠져 나가는 역할
        - break는 생략될 수 있다

-----------------------------------------------------------------------------
반복문
    - 규칙적인 작업을 할 때 반복문을 이용할 수 있다

    1. for문
        - 문법
        for(초기화; 조건식; 증감식){
            실행문;
        }
        - 초기화
            - 조건식, 증감식, 실행문에서 사용하는 변수들을 초기화 할 수 있다.
            - ,를 이용하여 여러 변수를 초기화 할 수 있다
            - 변수 선언도 가능하다
            - 변수를 선언하고 다른 변수를 초기화 할 수 없다.
        
        - 조건식
            - 반복문을 실행할지 말지를 결정하는 곳
            - 처음 거짓이 되는 순간 반복문을 종료
            - 생략 가능
            - 생략하면 true가 됨 (무한루프)
        
        - 증감식
            - 주로 조건식에서 사용하는 변수를 증가하거나 감소시켜 반복 횟수를 조절할 때 사용
            - 생략가능
        
        - 증감식, 조건식, 초기화를 이용하여 반복 횟수를 결정

    2. while문
        - 문법
        while(조건식){
            실행문;
        }
        - 조건식
            - 생략할 수 없음
            - 역할은 for문의 조건식과 같음

    2. do while문
        - 문법
        do{

        }while(조건식);
        - 무조건 1번은 실행
        - 조건식
            - 생략할 수 없음
            - 역할은 for문의 조건식과 같음

    3. 향상된 for문
        - 문법
        for(자료형 변수명 : 컬렉션이나 배열) {
            실행문;
        }
        - 컬렉션이나 배열에 있는 값들을 하나씩 꺼내서 확인할 때 사용하는

---------------------------------------------------------------------------------
배열
    - 같은 타입의 값들을 관리할 때 배열을 이용할 수 있다.
    - 컬렉션을 이용하면 배열보다 더 편하게 사용할 수 있다.
    - (같은 의미) 같은 자료형의 데이터를 여러 개 관리할 때 배열을 사용
    - 배열생성
        자료형 배열명 [] = new 자료형[크기];
        자료형 [] 배열명 = new 자료형[크기];
    - 배열 초기화
        자료형 배열명 [] = new 자료형[]{값1, 값2, ....};
        자료형 배열명 [] = {값1, 값2, ....};
        배열명 = new 자료형[]{값1, 값2, ...}; //가능
        배열명 = {값1, 값2, ....};  //불가능
    - 배열은 0번지 시작
    - 배열의 크기
        - 배열명.length 를 통해 배열의 크기를 알 수 있다.
    - 배열의 사용
        - 배열명[번지]를 이용하여 변수처럼 사용할 수 있다

------------------------------------------------------------------------------------
클래스
    - 현실의 정보를 클래스로 선언할 수 있다
    - 클래스를 이용하여 프로그램을 작성할 수 있다

    1. 추상화
        - 현실의 정보를 클래스로 만드는것

    2. 클래스
        - 현실의 정보를 코드로 구현한 것

    3. 클래스를 왜 쓸까?
        - 하나의 정보를 나타내는 여러 변수들을 따로 관리하면 불편하기 때문에
        묶어서 하나의 클래스로 만들어서 사용

    -구성
        1. 멤버 변수
            - 클래스를 구성하는 정보
            - 일반적으로 접근 제어자를 private설정 후 getter/setter를 추가
            - A는 B를 가지고 있다로 표현 가능한 경우, B는 A클래스의 멤버변수가 된다.(has a 관계)

        2. 메서드
            - 클래스에서 제공하는 기능
            - 문법
            [접근제어자] [final] [static] 리턴타입 메서드명(매개변수들){
                구현;
            }
            - 매개변수
                - 메서드를 실행하기 위해 반드시 필요한 정보
                - 없을 수도 있다
            - 리턴타입
                - 기능 실행 후 알려줘야 하는 값들의 자료형

        3. 생성자
            - 객체를 생성한 후 생성자를 호출
            - 멤버 변수들을 초기화를 함
            - 문법
            접근제어자 클래스명(매개변수들){
                초기화;
            }
            - 접근제어자는 일반적으로 public
            - 매개변수가 없으면 기본생성자
            - 생성자 오버로딩을 이용하여 다양한 생성자를 만들 수 있다

        4. 객체 생성 및 사용
        클래스명 객체명 = new 클래스명();
        객체명.멤버변수1 = 값;
        객체명.메서드();

        5. 접근제어자
            1. private
                - 본인 클래스만 사용가능
            2. default
                - 본인 클래스 + 같은 패키지 클래스만 사용 가능
                - default 키워드를 이용하는 것이 아니라 생략해야함
            3. protected
                - 본인 클래스 + 같은 패키지 + 자식 클래스만 사용가능
            4. public 
                - 모두 사용 가능

        6. this
            - 본인 스스로를 가르키는 예약어
            - 주로 생성자나 메서드에서 매개변수명과 멤버변수 명이 같은 경우 this를 반드시 사용

        7. this()
            - 본인 생성자 중 다른 생성자를 호출




-------------------------------------------------------------------------------------------
제네릭
    - 라이브러리에서 제공하는 제네릭 클래스와 인터페이스를 사용할 수 있다
    - 멤버변수 또는 메서드의 타입이 정해지지 않은 클래스/인터페이스
    - 객체를 생성할 때 타입이 정해짐
    - 타입으로는 클래스만 올 수 있다. => 기본 자료형은 올 수 없다. => Wrapper클래스를 이용
    - 제네릭 클래스 객체 생성
    클래스명<타입> 객체명 = new 클래스명<타입>();

-------------------------------------------------------------------------------------------
컬렉션 프레임 워크
    - 컬렉션과 맵에서 제공하는 메서드를 사용할 수 있다.
    - 컬렉션 프레임워크는 컬렉션 + 맵
    - Collection 인터페이스
        -   한 종류의 값을 관리
        1. List 인터페이스
            - 순서 보장, 중복 가능
            - 번지를 통해 접근 가능
            - ArrayList, LinkedList

        2. Set 인터페이스
            - 순서 보장x, 중복 불가능
            - 번지를 통해 접근 불가
            - HashSet, TreeSet

    - Map 인터페이스
        - 두 종류의 값을 관리
            - Key, Value
            - Key 중복 불가능
            - Value 중복 가능

---------------------------------------------------------------------------------------------
람다식
    - 람다식을 활용할 수 있다.
    - 함수형 인터페이스의 구현 클래스가 필요한 경우 사용
    - 함수형 인터페이스
        - 인터페이스의 추상 메서드가 1개인 인터페이스
    - 문법
    //메서드
    리턴타입 메서드명(자료형 매개변수1, 자료형 매개변수2, ....){
        구현;
    }
    //람다식
    (매개변수1, 매개변수2)->{
        실행문;
    }
    //간소화된 람다식 : 매개변수가 1개 - ()를 생략, 실행문이 1줄 - {}와 ;를 생략
    매개변수1 -> 실행문

    - 함수형 인터페이스
        1. Consumer : 매개변수 o, 리턴 x
        2. Supplier : 매개변수 x, 리턴 o
        3. Function : 매개변수 o, 리턴 o, 매개변수 타입과 리턴 타입이 다름
        4. Operator : 매개변수 o, 리턴 o, 매개변수 타입과 리턴 타입이 같음
        5. Predicate: 매개변수 o, 리턴 o, 리턴이 논리형

    - 사용 예
        - List에서 sort로 정렬할 때
        - Thread 생성할 때 Runable 인터페이스를 이용하는 경우
        - Stream에서 메서드들을 이용할 때

---------------------------------------------------------------------------------------------
스트림
    - 컬렉션이나 배열을 람다식으로 처리할 수 있게 해주는 반복자
    - 스트림 생성
    //배열
    int arr[] = ...;
    Stream stream = Arrays.stream(arr);

    //리스트
    List<Integer> list = ...;
    Stream stream = list.stream();

    - filter
        - Predicate 인터페이스의 객체가 필요
        - 람다식으로 구현o
        - 조건을 만족하는 요소들만 선택

    - map
        - Function 인터페이스의 객체가 필요
        - 람다식으로 구현o
        - 스트림의 요소들을 다른 구조로 변환

    - forEach
        - Consumer 인터페이스의 객체가 필요
        - 람다식으로 구현o
        - 스트림의 각 요소들이 실행할 코드를 구현

    - 집계함수
        - count(), sum(), average()

    - 사용자 집계 함수
        - reduce()

---------------------------------------------------------------------------------------------
자바 입출력
    1. 기반 스트림
        - 스트림 자체로 읽고/쓰기를 할 수 있는 스트림

    2. 보조 스트림
        - 스트림 자체로 읽고/쓰기를 할 수 없어서 기반 스트림을 통해 읽고/쓰기를 함
        - 성능향상을 위해
            - 가져온 데이터를 쉽게 문자열로, 객체로
            - 여러 개를 한 번에 가져와서 속도를 향상

    3. InputStream
        - 스트림을 통해 읽어올 때 사용

    4. OutputStream
        - 스트림을 통해 쓸 때 사용

---------------------------------------------------------------------------------------------
쓰레드
    - 프로세스 내에서 실행하는 작업의 단위
    - 멀티 쓰레드
        - 여러 쓰레드를 생성해서 동시에(병렬) 작업을 할 수 있게 함

    - 쓰레드 생성 방법
        1. Thread 클래스 상속
        class MyThread extends Thread{
            //run() 오버라이딩 선택
        }

        2. Runable 인터페이스의 구현 클래스 (반드시 오버라이딩 필요)
        class MyThread implements Runable{
            //run() 오버라이딩이 필수
            @Override
            public void run(){

            }
        }

    - 쓰레드 실행
        - thread.start()를 통해 실행
        - start() 를 이용한 경우
            - 새 쓰레드를 생성
            - 새 쓰레드에 run()메서드를 실행

        - run() 을 이용한 경우
            - 기존 쓰레드에 run()메서드를 실행

    - 동기화, 교착상태 주의

---------------------------------------------------------------------------------------------
네트워크
    - 소켓 통신을 할 수 있다.
    - 서버 코드와 클라이언트 코드를 작성해서 통신을 할 수 있다.

---------------------------------------------------------------------------------------------
용어 정리
1. 상수
    - 변수 앞에 final이 붙어 있으면 상수
    - 이름이 있는 리터럴이라고 생각하면 편함

2. 리터럴
    - 1, 2, 'a', 3.14, "문자열" 등과 같이 직접적인 값